// src/main.rs
mod pdf;
mod utils;
mod ui;

use gtk::prelude::*;
use gtk::glib;
use gtk::gio;

use crate::ui::window::ShelfWindow;

const APP_ID: &str = "org.galib.shelf";

fn main() -> glib::ExitCode {
    gio::resources_register_include!("compiled.gresource").expect("Failed to register resource");
    let app = gtk::Application::builder().application_id(APP_ID).build();
    app.connect_activate(app_main);
    app.run()
}

fn app_main(app: &gtk::Application) {
    // let window = gtk::ApplicationWindow::builder()
    //         .application(app)
    //         .title("Shelf")
    //         .build();
    // Create UI elements

    let window = ShelfWindow::new(app);
     
    window.present();
}

// src/pdf.rs
#![allow(dead_code)]

use std::{fs::create_dir_all, path::{Path, PathBuf}, time::Duration};

use anyhow::{Context, Result};
use image::RgbImage;
use mupdf::{Document, Matrix, MetadataName};
use r2d2::Pool;
use r2d2_sqlite::SqliteConnectionManager;
use rusqlite::params;
use crate::utils::*;

#[derive(Debug, Clone)]
pub enum ScanProgress {
    Found(PathBuf),
    Processing(PathBuf),
    Extracted(String, PdfMetadata),
    DuplicateDetected(PathBuf, PathBuf),
    Error(PathBuf, String),
    Complete(Vec<PdfMetadata>, Duration),
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct PdfMetadata {
    pub hash: String,
    pub partial_hash: String,
    pub path: String,
    pub title: Option<String>,
    pub author: Option<String>,
    pub subject: Option<String>,
    pub keywords: Option<String>,
    pub creator: Option<String>,
    pub producer: Option<String>,
    pub creation_date: Option<String>,
    pub modification_date: Option<String>,
    pub page_count: u32,
    pub cover_path: Option<String>,
    pub file_size: u64,
}

pub struct PdfCache {
    pool: Pool<SqliteConnectionManager>,
    // conn: Connection,
    cache_dir: PathBuf,
}

impl PdfCache {
    pub fn new() -> Result<Self> {
        let cache_dir = dirs::home_dir().unwrap().join(".shelf");
        
        create_dir_all(&cache_dir)?;
        create_dir_all(cache_dir.join("covers"))?;
        
        let db_path = cache_dir.join("pdf_cache.db");
        let manager = SqliteConnectionManager::file(&db_path);
        let pool = Pool::new(manager)?;

        {
            let conn = pool.get()?;
            conn.execute(
                "CREATE TABLE IF NOT EXISTS pdf_metadata (
                    hash TEXT PRIMARY KEY,
                    partial_hash TEXT NOT NULL,
                    path TEXT NOT NULL,
                    title TEXT,
                    author TEXT,
                    subject TEXT,
                    keywords TEXT,
                    creator TEXT,
                    producer TEXT,
                    creation_date TEXT,
                    modification_date TEXT,
                    page_count INTEGER NOT NULL,
                    cover_path TEXT,
                    file_size INTEGER NOT NULL,
                    last_seen INTEGER NOT NULL
                )",
                [],
            )?;
            
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_partial_hash ON pdf_metadata(partial_hash)",
                [],
            )?;
            
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_path ON pdf_metadata(path)",
                [],
            )?;
        }
        
        Ok(Self { pool, cache_dir })
    }
    
    pub fn get_by_partial_hash(&self, partial_hash: &str, file_size: u64) -> Result<Vec<PdfMetadata>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare(
            "SELECT * FROM pdf_metadata WHERE partial_hash = ?1 AND file_size = ?2"
        )?;
        
        let results = stmt.query_map(params![partial_hash, file_size], |row| {
            Ok(PdfMetadata {
                hash: row.get(0)?,
                partial_hash: row.get(1)?,
                path: row.get(2)?,
                title: row.get(3)?,
                author: row.get(4)?,
                subject: row.get(5)?,
                keywords: row.get(6)?,
                creator: row.get(7)?,
                producer: row.get(8)?,
                creation_date: row.get(9)?,
                modification_date: row.get(10)?,
                page_count: row.get(11)?,
                cover_path: row.get(12)?,
                file_size: row.get(13)?,
            })
        })?;
        
        results.collect::<Result<Vec<_>, _>>().map_err(Into::into)
    }
    
    pub fn get_metadata(&self, hash: &str) -> Result<Option<PdfMetadata>> {
        let conn = self.pool.get()?;
        let mut stmt = conn.prepare(
            "SELECT * FROM pdf_metadata WHERE hash = ?1"
        )?;
        
        let result = stmt.query_row(params![hash], |row| {
            Ok(PdfMetadata {
                hash: row.get(0)?,
                partial_hash: row.get(1)?,
                path: row.get(2)?,
                title: row.get(3)?,
                author: row.get(4)?,
                subject: row.get(5)?,
                keywords: row.get(6)?,
                creator: row.get(7)?,
                producer: row.get(8)?,
                creation_date: row.get(9)?,
                modification_date: row.get(10)?,
                page_count: row.get(11)?,
                cover_path: row.get(12)?,
                file_size: row.get(13)?,
            })
        });
        
        match result {
            Ok(metadata) => Ok(Some(metadata)),
            Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
            Err(e) => Err(e.into()),
        }
    }
    
    pub fn store_metadata(&self, metadata: &PdfMetadata) -> Result<()> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_secs();
        
        let conn = self.pool.get()?;
        conn.execute(
            "INSERT OR REPLACE INTO pdf_metadata 
            (hash, partial_hash, path, title, author, subject, keywords, creator, producer, 
             creation_date, modification_date, page_count, cover_path, file_size, last_seen)
            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15)",
            params![
                metadata.hash,
                metadata.partial_hash,
                metadata.path,
                metadata.title,
                metadata.author,
                metadata.subject,
                metadata.keywords,
                metadata.creator,
                metadata.producer,
                metadata.creation_date,
                metadata.modification_date,
                metadata.page_count,
                metadata.cover_path,
                metadata.file_size,
                now,
            ],
        )?;
        
        Ok(())
    }
}

/// Compute partial hash from:
/// - First 64KB of file
/// - Last 64KB of file
/// - File size
/// This is ~1000x faster than full hash for large files

pub fn extract_pdf_metadata(
    path: &Path,
    cache: &PdfCache,
    tx: &async_channel::Sender<ScanProgress>,
) -> Result<PdfMetadata> {
    // Step 1: Compute fast partial hash
    let (partial_hash, file_size) = compute_partial_hash(path)?;
    
    // Step 2: Check cache for matches with same partial hash and size
    let cached_matches = cache.get_by_partial_hash(&partial_hash, file_size)?;
    
    // Step 3: Handle cache hits
    if !cached_matches.is_empty() {
        let first_hit = cached_matches[0].clone();
        // Check if any cached entry has matching full hash
        if cached_matches.len() > 1 {
            let full_hash = compute_full_hash(path)?;
            for cached in cached_matches {
                if cached.hash == full_hash {
                    // Exact match found - update path if changed
                    if cached.path != path.to_string_lossy() {
                        let _ = tx.send_blocking(ScanProgress::DuplicateDetected(
                            PathBuf::from(&cached.path),
                            path.to_path_buf(),
                        ));
                    }
                    
                    // Return cached metadata with updated path
                    let mut updated = cached.clone();
                    updated.path = path.to_string_lossy().to_string();
                    cache.store_metadata(&updated)?;
                    return Ok(updated);
                }
            }
        } else {
            return Ok(first_hit); 
        }
    }
    
    println!("New file detected - {}", path.display());
    // Step 4: No cache hit - extract metadata from PDF
    let document = Document::open(path).unwrap();
    let page_count = document.page_count().unwrap() as u32;
    // let format = document.metadata(MetadataName::Format).ok();
    // let encryption = document.metadata(MetadataName::Encryption).ok();
    let author = document.metadata(MetadataName::Author).ok();
    let title = document.metadata(MetadataName::Title).ok();
    let producer = document.metadata(MetadataName::Producer).ok();
    let creator = document.metadata(MetadataName::Creator).ok();
    let creation_date = document.metadata(MetadataName::CreationDate).ok();
    let modification_date = document.metadata(MetadataName::ModDate).ok();
    let subject = document.metadata(MetadataName::Subject).ok();
    let keywords = document.metadata(MetadataName::Keywords).ok();
    
    // Compute full hash now (we need it for unique identification)
    let full_hash = compute_full_hash(path)?;
    
    // Step 5: Extract cover image
    let cover_path = if page_count > 0 {
        let page = document.load_page(0)?;
        
        // Calculate scale from DPI (default PDF is 72 DPI)
        let scale = 1.0;
        let matrix = Matrix::new_scale(scale, scale);
        
        // Render page to pixmap
        let pixmap = page.to_pixmap(&matrix, &mupdf::Colorspace::device_rgb(), false, true)?;
        
        // Convert to image and save
        let width = pixmap.width() as u32;
        let height = pixmap.height() as u32;
        let samples = pixmap.samples();
        
        let image = RgbImage::from_raw(width, height, samples.to_vec())
            .context("Failed to create image from pixmap")?;
         
        let cover_filename = format!("{}.jpg", &full_hash[..16]);
        let cover_full_path = cache.cache_dir.join("covers").join(&cover_filename);
        
        image.save(&cover_full_path)?;
        Some(cover_filename)
    } else {
        None
    };
    
    let metadata = PdfMetadata {
        hash: full_hash,
        partial_hash,
        path: path.to_string_lossy().to_string(),
        title,
        author,
        subject,
        keywords,
        creator,
        producer,
        creation_date,
        modification_date,
        page_count,
        cover_path,
        file_size,
    };
    
    // Step 6: Store in cache
    println!("storing cache");
    cache.store_metadata(&metadata)?;
    
    Ok(metadata)
}



// src/ui/grid_item.rs
use gtk::glib;
use gtk::subclass::prelude::*;

use crate::ui::models::PdfMetadataObject;

mod imp {
    use super::*; 

    #[derive(Default, gtk::CompositeTemplate)]
    #[template(string = r#"
        <interface>
          <template class="ShelfGridItem" parent="GtkBox">
            <property name="orientation">vertical</property>
            <!-- <property name="spacing">24</property> -->
            <property name="margin-start">12</property>
            <property name="margin-end">12</property>
            <property name="margin-top">12</property>
            <property name="margin-bottom">12</property>
            
            <!-- <style> -->
            <!--   <class name="card"/> -->
            <!-- </style> -->
            
            <child>
              <object class="GtkImage" id="cover_image">
                <property name="pixel-size">128</property>
                <property name="halign">center</property>
              </object>
            </child>
            
          </template>
        </interface>
        "#)]
    pub struct ShelfGridItem {
        #[template_child]
        pub cover_image: TemplateChild<gtk::Image>,
    }

    #[glib::object_subclass]
    impl ObjectSubclass for ShelfGridItem {
        const NAME: &'static str = "ShelfGridItem";
        type Type = super::ShelfGridItem;
        type ParentType = gtk::Box;

        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
        }

        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }

    impl ObjectImpl for ShelfGridItem {}
    impl WidgetImpl for ShelfGridItem {}
    impl BoxImpl for ShelfGridItem {}
}

glib::wrapper! {
    pub struct ShelfGridItem(ObjectSubclass<imp::ShelfGridItem>)
        @extends gtk::Box, gtk::Widget,
        @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
}

impl ShelfGridItem {
    pub fn new() -> Self {
        glib::Object::builder().build()
    }

    pub fn bind(&self, pdf_metadata_object: &PdfMetadataObject) {
        let imp = self.imp();
        if let Some(metadata) = pdf_metadata_object.metadata() {
            if let Some(cover_path) = metadata.cover_path {
                let cover_path = dirs::home_dir().unwrap().join(".shelf").join("covers").join(cover_path);
                if std::path::Path::new(&cover_path).exists() {
                    imp.cover_image.set_from_file(Some(&cover_path));
                } else {
                    imp.cover_image.set_icon_name(Some("x-office-document"));
                }
            } else {
                imp.cover_image.set_icon_name(Some("x-office-document"));
            } 
        }
    } 
}

// src/ui/mod.rs
pub mod window;
pub mod settings_window;
pub mod models;
pub mod grid_item;

// src/ui/models.rs
use gtk::glib::{self, subclass::types::ObjectSubclassIsExt};

use crate::pdf::PdfMetadata;

mod imp {
    use std::cell::RefCell;
    use gtk::glib;
    use gtk::glib::subclass::{object::ObjectImpl, types::ObjectSubclass};

    use crate::pdf::PdfMetadata;

    #[derive(Debug, Default)]
    pub struct PdfMetadataObject {
        pub metadata: RefCell<Option<PdfMetadata>>,
    }

    #[glib::object_subclass]
    impl ObjectSubclass for PdfMetadataObject {
        const NAME: &'static str = "PdfMetadataObject";
        type Type = super::PdfMetadataObject;
        type ParentType = glib::Object;
    }

    impl ObjectImpl for PdfMetadataObject {}
}

glib::wrapper! {
    pub struct PdfMetadataObject(ObjectSubclass<imp::PdfMetadataObject>);
}

impl PdfMetadataObject {
    pub fn new(metadata: PdfMetadata) -> Self {
        let obj: Self = glib::Object::new();
        obj.imp().metadata.replace(Some(metadata));
        obj
    }

    pub fn metadata(&self) -> Option<PdfMetadata> {
        self.imp().metadata.borrow().clone()
    }
}

// src/ui/settings_window.rs
#![allow(dead_code)]

use gtk::glib::subclass::types::ObjectSubclassIsExt;
use gtk::prelude::*;
use gtk::glib;
use gtk::gio;

mod imp {
    use gtk::glib;
    use gtk::glib::subclass::types::ObjectSubclass;
    use gtk::subclass::prelude::*;

    #[derive(Default, gtk::CompositeTemplate)]
    #[template(resource = "/org/galib/shelf/ui/settings_window.xml")]
    pub struct ShelfSettingsWindow {
    }

    #[glib::object_subclass]
    impl ObjectSubclass for ShelfSettingsWindow {
        const NAME: &'static str = "ShelfSettingsWindow";
        type Type = super::ShelfSettingsWindow;
        type ParentType = gtk::Window;

        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
        }

        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }

    impl ObjectImpl for ShelfSettingsWindow {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj();
            obj.setup();
        }
    }
    impl WidgetImpl for ShelfSettingsWindow {}
    impl WindowImpl for ShelfSettingsWindow {}
}

glib::wrapper! {
    pub struct ShelfSettingsWindow(ObjectSubclass<imp::ShelfSettingsWindow>)
        @extends gtk::Widget, gtk::Window,
        @implements gio::ActionGroup, gio::ActionMap,
                    gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native,
                    gtk::Root, gtk::ShortcutManager;
}

impl ShelfSettingsWindow {
    pub fn new() -> Self {
        glib::Object::builder().build()
    }

    fn setup(&self) {
        let imp = self.imp();
    } 
}

// src/ui/window.rs
#![allow(dead_code)]

use std::path::PathBuf;
use std::process::Command;
use std::sync::Arc;
use std::time::Instant;

use fuzzy_matcher::skim::SkimMatcherV2;
use fuzzy_matcher::FuzzyMatcher;
use gtk::glib::subclass::types::ObjectSubclassIsExt;
use gtk::{prelude::*, SignalListItemFactory, SingleSelection};
use gtk::glib;
use gtk::gio;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};

use crate::pdf::{extract_pdf_metadata, PdfCache, PdfMetadata, ScanProgress};
use crate::ui::grid_item::ShelfGridItem;
use crate::ui::models::PdfMetadataObject;
use crate::ui::settings_window::ShelfSettingsWindow;
use crate::utils::scan_pdfs_rayon;
use super::models;

mod imp {
    use std::sync::{Arc, Mutex};

    use gtk::glib;
    use gtk::glib::subclass::types::ObjectSubclass;
    use gtk::subclass::prelude::*;

    use crate::pdf::PdfMetadata;

    #[derive(Default, gtk::CompositeTemplate)]
    #[template(resource = "/org/galib/shelf/ui/window.xml")]
    pub struct ShelfWindow {
        #[template_child]
        pub info_label: TemplateChild<gtk::Label>,
        #[template_child]
        pub refresh_button: TemplateChild<gtk::Button>,
        #[template_child]
        pub settings_button: TemplateChild<gtk::Button>,
        #[template_child]
        pub search_button: TemplateChild<gtk::Button>,
        #[template_child]
        pub search_entry: TemplateChild<gtk::SearchEntry>,
        #[template_child]
        pub status_label: TemplateChild<gtk::Label>,
        #[template_child]
        pub grid_view: TemplateChild<gtk::GridView>,

        // Store for PDF files
        pub metadata_list: Arc<Mutex<Vec<PdfMetadata>>>, 
        pub selected: Arc<Mutex<Option<PdfMetadata>>>,
    }

    #[glib::object_subclass]
    impl ObjectSubclass for ShelfWindow {
        const NAME: &'static str = "ShelfWindow";
        type Type = super::ShelfWindow;
        type ParentType = gtk::ApplicationWindow;

        fn class_init(klass: &mut Self::Class) {
            klass.bind_template();
        }

        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }

    impl ObjectImpl for ShelfWindow {
        fn constructed(&self) {
            self.parent_constructed();
            let obj = self.obj();
            obj.setup();
        }
    }
    impl WidgetImpl for ShelfWindow {}
    impl WindowImpl for ShelfWindow {}
    impl ApplicationWindowImpl for ShelfWindow {}
}

glib::wrapper! {
    pub struct ShelfWindow(ObjectSubclass<imp::ShelfWindow>)
        @extends gtk::Widget, gtk::Window, gtk::ApplicationWindow,
        @implements gio::ActionGroup, gio::ActionMap,
                    gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native,
                    gtk::Root, gtk::ShortcutManager;
}

impl ShelfWindow {
    pub fn new(app: &gtk::Application) -> Self {
        glib::Object::builder().property("application", app).build()
    }

    fn setup(&self) {
        let imp = self.imp();
        let model = gio::ListStore::new::<models::PdfMetadataObject>();
        let selection_model = SingleSelection::new(Some(model.clone()));
        selection_model.set_selected(0);
        let factory = SignalListItemFactory::new();

        let selected_clone = imp.selected.clone();
        selection_model.connect_selection_changed(move |_self, _, _| {
            let item = _self.selected_item().unwrap();
            let metadata_object = item.downcast_ref::<PdfMetadataObject>().unwrap();
            {
                let mut selected = selected_clone.lock().unwrap();
                *selected = metadata_object.metadata();
            }
        });

        let status_label_for_factory = imp.status_label.clone();
        let selected_for_factory = imp.selected.clone();
        factory.connect_setup(move |_grid, item| {
            let grid_item = ShelfGridItem::new();
            let list_item = item.downcast_ref::<gtk::ListItem>().unwrap();
            list_item.set_child(Some(&grid_item));
            
            // Add motion controller once during setup
            let motion_controller = gtk::EventControllerMotion::new();
            let status_label = status_label_for_factory.clone();
            let selected = selected_for_factory.clone();
            
            let list_item_weak = list_item.downgrade();
            motion_controller.connect_enter(move |_, _, _| {
                if let Some(list_item) = list_item_weak.upgrade() {
                    if let Some(obj) = list_item.item() {
                        if let Some(pdf_obj) = obj.downcast_ref::<PdfMetadataObject>() {
                            if let Some(metadata) = pdf_obj.metadata() {
                                status_label.set_text(&metadata.path);
                            }
                        }
                    }
                }
            });
    
            let status_label = status_label_for_factory.clone();
            motion_controller.connect_leave(move |_| {
                let selected = selected.lock().unwrap();
                if let Some(metadata) = selected.as_ref() {
                    status_label.set_text(&metadata.path);
                }
            });
            
            grid_item.add_controller(motion_controller);
        });
        
        factory.connect_bind(move |_, item| {
            let item = item.downcast_ref::<gtk::ListItem>().unwrap();
            let pdf_metadata_object = item.item().and_downcast::<PdfMetadataObject>().unwrap();
            let grid_item = item.child().and_downcast::<ShelfGridItem>().unwrap();
            grid_item.bind(&pdf_metadata_object);
        });

        imp.grid_view.set_model(Some(&selection_model));
        imp.grid_view.set_factory(Some(&factory));
        imp.grid_view.set_min_columns(2);
        imp.grid_view.set_max_columns(6);
        imp.grid_view.set_single_click_activate(false);

        let search_entry = imp.search_entry.clone();
        imp.search_button.connect_clicked(move |_| {
            search_entry.set_visible(!search_entry.is_visible());
            search_entry.grab_focus();
        });

        imp.settings_button.connect_clicked(move |_| {
            let dialog = ShelfSettingsWindow::new();
            dialog.present();
        });

        let model_clone = model.clone();
        let status_label_clone = imp.status_label.clone();
        let scan_button_clone = imp.refresh_button.clone();
        let search_button_clone = imp.search_button.clone();
        let pdf_files_clone = imp.metadata_list.clone();
        let search_entry_clone = imp.search_entry.clone();
        imp.refresh_button.connect_clicked(move |_| {
            // we are cloning again because we will spawn our own thread
            let model = model_clone.clone();
            let progress_label = status_label_clone.clone();
            let scan_button = scan_button_clone.clone();
            let search_button = search_button_clone.clone();
            let pdf_files = pdf_files_clone.clone();
            let search_entry = search_entry_clone.clone();
            
            // Disable button during scan
            scan_button.set_sensitive(false);
            search_button.set_sensitive(false);
            search_entry.set_visible(false);
            progress_label.set_text("Scanning...");
            
            // Clear previous results
            model.remove_all();
            search_entry.set_text("");
            let (tx, rx) = async_channel::unbounded::<ScanProgress>();
            std::thread::spawn(move || {
                let scan_dirs: Vec<PathBuf> = vec![
                    PathBuf::from("/home/galib"),
                    PathBuf::from("/mnt/data")
                ];

                let start_time = Instant::now(); 
                let cache = match PdfCache::new() {
                    Ok(c) => Arc::new(c),
                    Err(e) => {
                        let _ = tx.send_blocking(ScanProgress::Error(
                            PathBuf::from("cache"),
                            format!("Failed to initialize cache: {}", e)
                        ));
                        return;
                    }
                };
                let mut pdf_paths: Vec<PathBuf> = Vec::new();
                for dir in &scan_dirs {
                     pdf_paths.extend(scan_pdfs_rayon(dir, tx.clone()));
                } 
                pdf_paths.sort_unstable(); 
                                
                // Process PDFs in parallel
                // Replace the parallel processing section with:
                let metadata_list: Vec<PdfMetadata> = pdf_paths.par_iter().filter_map(|path| {
                    let _ = tx.send_blocking(ScanProgress::Processing(path.clone()));
                    let cache = cache.clone();

                    match extract_pdf_metadata(path, &cache, &tx) {
                        Ok(metadata) => Some(metadata),
                        Err(e) => {
                            let _ = tx.send_blocking(ScanProgress::Error(
                                path.clone(),
                                format!("Extraction failed: {}", e),
                            ));
                            None
                        }
                    }
                })
                .collect();

                let duration = start_time.elapsed();
                let _ = tx.send_blocking(ScanProgress::Complete(metadata_list, duration));
            });

            gtk::glib::spawn_future_local(async move {
                use std::cell::Cell;
                let count = Cell::new(0);
                
                while let Ok(msg) = rx.recv().await {
                    match msg {
                        ScanProgress::Found(_path) => {
                            count.set(count.get() + 1);
                            progress_label.set_text(&format!("Found {} PDFs...", count.get())); 
                        }
                        ScanProgress::Processing(path) => {
                            progress_label.set_text(&format!("Processing: {}...", path.display()));
                        }
                        ScanProgress::Extracted(_hash, metadata) => {
                            progress_label.set_text(&format!("Extracted: {}...", 
                                metadata.title.as_deref().unwrap_or("Untitled")));
                            // model.append(&PdfMetadataObject::new(metadata));
                        }
                        ScanProgress::DuplicateDetected(original, duplicate) => {
                            println!("Duplicate detected: {} is duplicate of {}", 
                                duplicate.display(), original.display());
                        }
                        ScanProgress::Error(path, error) => {
                            eprintln!("Error processing {}: {}", path.display(), error);
                        }
                        ScanProgress::Complete(metadata_list, duration) => {
                            for item in &metadata_list {
                                model.append(&PdfMetadataObject::new(item.to_owned()));
                            }
                            progress_label.set_text(&format!(
                                "Complete! Found {} PDF files in {:.2?}",
                                metadata_list.len(),
                                duration
                            ));
                            // Store all PDFs for searching
                            {
                                let mut files = pdf_files.lock().unwrap();
                                *files = metadata_list;
                            }
  
                            scan_button.set_sensitive(true);
                            search_button.set_sensitive(true);
                            // search_entry.set_sensitive(true);
                            search_entry.grab_focus();
                            break;
                        }
                    }
                }
            });
        });

        let model_clone = model.clone();
        imp.grid_view.connect_activate(move |_, position| {
            let item = model_clone.item(position).unwrap();
            let metadata_object = item.downcast_ref::<PdfMetadataObject>().unwrap(); 
            if let Some(metadata) = metadata_object.metadata() {
                let path = metadata.path.clone();
                // Spawn Zathura in a separate process
                std::thread::spawn(move || {
                    match Command::new("zathura")
                        .arg(path.as_str())
                        .spawn() {
                        Ok(_) => println!("Opened {} with Zathura", path),
                        Err(e) => eprintln!("Failed to open {}: {}", path, e),
                    }
                });
            } 
        });

        let model_search = model.clone();
        let pdf_files_search = imp.metadata_list.clone();

        imp.search_entry.connect_search_changed(move |entry| {
            let query = entry.text();
            
            let pdf_files = match pdf_files_search.lock() {
                Ok(files) => files,
                Err(poisoned) => poisoned.into_inner()
            };
            
            model_search.remove_all();
            
            if query.is_empty() {
                for item in pdf_files.iter() {
                    model_search.append(&PdfMetadataObject::new(item.clone()));
                }
            } else {
                let matcher = SkimMatcherV2::default();
                let query_str = query.as_str();
                
                let mut scored: Vec<(&PdfMetadata, i64)> = pdf_files
                    .par_iter()
                    .filter_map(|pdf| {
                        // Extract filename from path
                        let filename = std::path::Path::new(&pdf.path)
                            .file_name()
                            .and_then(|n| n.to_str())
                            .unwrap_or("");
                        
                        let searchable = format!(
                            "{} {} {}",
                            filename, 
                            pdf.title.as_deref().unwrap_or(""),
                            pdf.author.as_deref().unwrap_or("")
                        );
                        
                        matcher.fuzzy_match(&searchable, query_str)
                            .map(|score| (pdf, score))
                    })
                    .collect();
                
                scored.sort_unstable_by(|a, b| b.1.cmp(&a.1));
                scored.truncate(10);
                
                for (metadata, _) in scored {
                    model_search.append(&PdfMetadataObject::new(metadata.clone()));
                }
            }
        });

        imp.refresh_button.emit_clicked();
    } 
}

// src/utils.rs
#![allow(dead_code)]

use std::{
    fs::{read_dir, File}, 
    io::{Read, Seek, SeekFrom}, path::{Path, PathBuf}
};
use anyhow::Result;
use blake3::Hasher;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};

use crate::pdf::ScanProgress;

// https://docs.rs/globmatch/latest/src/globmatch/utils.rs.html#133-145
pub fn is_hidden_path<P>(path: P) -> bool
where
    P: AsRef<Path>,
{
    let has_hidden = path.as_ref().components().find(|c| {
        c.as_os_str()
            .to_str()
            .map(|s| s.starts_with('.'))
            .unwrap_or(false)
    });

    has_hidden.is_some()
}

pub fn scan_pdfs_rayon(dir: &PathBuf, tx: async_channel::Sender<ScanProgress>) -> Vec<PathBuf> {
    let mut pdfs = Vec::new();
    let mut subdirs = Vec::new();
    let entries = read_dir(&dir).unwrap();

    for entry in entries.flatten() {
        let path = entry.path();
        if is_hidden_path(&path) { continue; }
        if path.is_file() && path.extension().is_some_and(|ext| ext.eq_ignore_ascii_case("pdf")) {
            pdfs.push(path.clone());
            let _ = tx.send_blocking(ScanProgress::Found(path));
        } else if path.is_dir() {
            subdirs.push(path);
        }
    }

    // Process subdirectories recursively in parallel
    let sub_pdfs: Vec<PathBuf> = subdirs
        .par_iter()
        .flat_map(|subdir| scan_pdfs_rayon(subdir, tx.clone()))
        .collect();

    pdfs.extend(sub_pdfs);
    pdfs
}

pub fn compute_partial_hash(path: &Path) -> Result<(String, u64)> {
    let mut file = File::open(path)?;
    let file_size = file.metadata()?.len();
    let mut hasher = Hasher::new();
    
    // Hash file size first (important discriminator)
    hasher.update(&file_size.to_le_bytes());
    
    // Hash first 64KB
    let mut buffer = vec![0u8; 65536];
    let n = file.read(&mut buffer)?;
    hasher.update(&buffer[..n]);
    
    // Hash last 64KB (if file is large enough)
    if file_size > 65536 {
        file.seek(SeekFrom::End(-65536))?;
        let n = file.read(&mut buffer)?;
        hasher.update(&buffer[..n]);
    }
    
    Ok((hasher.finalize().to_hex().to_string(), file_size))
}

/// Compute full file hash (only when needed for duplicate detection)
pub fn compute_full_hash(path: &Path) -> Result<String> {
    let mut file = File::open(path)?;
    let mut hasher = Hasher::new();
    let mut buffer = vec![0; 65536];
    
    loop {
        let n = file.read(&mut buffer)?;
        if n == 0 {
            break;
        }
        hasher.update(&buffer[..n]);
    }
    
    Ok(hasher.finalize().to_hex().to_string())
}

fn human_readable_file_size(bytes: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;
    
    if bytes >= GB {
        format!("{:.1} GB", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.1} MB", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.1} KB", bytes as f64 / KB as f64)
    } else {
        format!("{} B", bytes)
    }
}

